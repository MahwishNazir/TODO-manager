# Implementation Plan: Phase II Step 1 - REST API with Persistent Storage

**Branch**: `002-rest-api` | **Date**: 2026-01-12 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/002-rest-api/spec.md`

**Note**: This template is filled in by the `/sp.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Convert the Phase I console-based task manager to a web-based REST API with persistent PostgreSQL storage using FastAPI and SQLModel. Implement all 5 Basic Level task operations (Create, Read, Update, Delete, Mark Complete) as RESTful endpoints with user isolation based on URL path parameter (no authentication verification in Step 1). Data persists in Neon Serverless PostgreSQL across application restarts. This phase establishes the architectural foundation for adding authentication (Step 2) and Next.js frontend (Step 3) in subsequent work.

## Technical Context

**Language/Version**: Python 3.10+
**Primary Dependencies**: FastAPI 0.104+, SQLModel 0.0.14+, Uvicorn 0.24+, Psycopg2-binary 2.9+ or Asyncpg 0.29+
**Storage**: Neon Serverless PostgreSQL (cloud-hosted, accessed via DATABASE_URL environment variable)
**Testing**: pytest 7.4+, pytest-asyncio 0.21+, httpx 0.25+ (for FastAPI test client)
**Target Platform**: Linux/Windows server (Python ASGI application)
**Project Type**: Backend web API (single backend project, no frontend in Step 1)
**Performance Goals**:
- API response time: p95 < 200ms under 100 concurrent requests
- Database queries: p95 < 50ms for task lists up to 1000 tasks per user
- Support 20+ concurrent database connections via connection pooling

**Constraints**:
- No authentication or JWT validation in Step 1 (user_id trusted from URL path)
- No frontend implementation (API only)
- Must use SQLModel ORM (no raw SQL except for migrations)
- Database must be Neon Serverless PostgreSQL (no local PostgreSQL)
- Must support graceful shutdown to close database connections
- Title length limited to 500 characters
- user_id limited to 50 characters (alphanumeric, hyphens, underscores only)

**Scale/Scope**:
- 6 REST endpoints (GET/POST/PUT/DELETE/PATCH)
- 1 database table (tasks)
- Support multiple users with data isolation
- Handle up to 1000 tasks per user without performance degradation

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Core Principles Compliance

âœ… **I. Phased Development Approach (MANDATORY)**
- This is Phase II Step 1 as defined in constitution
- Builds on Phase I console app (foundation proven)
- Fully functional and testable before advancing to Step 2 (authentication)
- Preserves functionality: All 5 Basic Level operations from Phase I remain
- Data structures support backward compatibility (user_id column prepared for future auth)

âœ… **II. Spec-Driven Development (NON-NEGOTIABLE)**
- Spec created: `specs/002-rest-api/spec.md` (533 lines, comprehensive)
- Plan being created: This file (`specs/002-rest-api/plan.md`)
- Tasks will follow: `/sp.tasks` command next
- PHR created: `history/prompts/002-rest-api/001-rest-api-spec-creation.spec.prompt.md`
- ADRs will be suggested for architectural decisions (FastAPI vs alternatives, SQLModel choice, Neon DB selection)

âœ… **III. Test-First Development (NON-NEGOTIABLE)**
- TDD cycle will be followed in implementation
- Unit tests for models, services (SQLModel operations)
- Integration tests for API endpoints (httpx test client)
- Contract tests for API schemas (OpenAPI validation)
- Target: â‰¥80% code coverage per constitution

âœ… **IV. Separation of Concerns**
- Backend-only implementation (frontend deferred to Step 3)
- API contracts documented in OpenAPI (auto-generated by FastAPI)
- Clear interface boundaries: REST endpoints with JSON schemas
- Prepared for frontend integration: CORS headers configured

âœ… **V. Feature Tiering and Progressive Enhancement**
- Implementing Basic Level tier only in Step 1:
  - Add Task âœ“
  - Delete Task âœ“
  - Update Task âœ“
  - View Task List âœ“
  - Mark as Complete/Incomplete âœ“
- Intermediate and Advanced tiers deferred per spec (search, priorities, due dates)

âœ… **VI. Technology Stack Discipline**
- Phase II stack followed exactly:
  - Backend: FastAPI (Python 3.10+) âœ“
  - ORM: SQLModel âœ“
  - Database: Neon DB (PostgreSQL) âœ“
  - Testing: pytest âœ“
- No deviations from constitutional requirements

âœ… **VII. Data Integrity and Migration**
- Phase I â†’ II migration supported:
  - Console app can export to JSON (if implemented in Phase I)
  - Database schema accepts imported tasks
  - Migration script path documented in spec
- Data validation on all inputs
- Database constraints and indexes defined
- Rollback strategy: Drop table and recreate (acceptable for Step 1 with no production data)

### Technology Stack Standards Compliance

âœ… **Code Quality**:
- PEP 8 compliance (enforced via black formatter)
- Type hints required for all public functions (FastAPI + SQLModel encourage this)
- Google-style docstrings for all modules, classes, functions
- Linting: pylint (score â‰¥8.0/10), mypy (zero errors)

âœ… **Security**:
- Input validation via Pydantic models (built into FastAPI)
- SQL injection prevention via SQLModel parameterized queries
- CORS configuration for frontend integration
- Secrets management: DATABASE_URL in environment variables only
- Note: Authentication deferred to Step 2 per phased approach

âœ… **Performance**:
- Response time targets: p95 < 200ms âœ“ (specified in NFR-001)
- Database query targets: p95 < 100ms âœ“ (spec says <50ms, exceeds requirement)
- Connection pooling configured (20 connections per NFR-002)

âœ… **Observability**:
- Structured logging (FastAPI middleware for request logging)
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Request correlation via FastAPI request ID middleware (optional)

### Development Workflow Compliance

âœ… **Spec-Driven Cycle**:
1. User Request âœ“ (received via /sp.specify command)
2. Create/Update Spec âœ“ (`specs/002-rest-api/spec.md` created)
3. Architectural Planning âœ“ (this plan.md)
4. Task Breakdown â†’ Next: `/sp.tasks` command
5. Implementation â†’ Follow TDD (Red-Green-Refactor)
6. Verification â†’ Confirm working at task completion
7. Documentation â†’ PHR created, ADRs will follow
8. User Checkpoint â†’ Demo API endpoints, get approval

**GATE RESULT**: âœ… **ALL CHECKS PASS** - Proceed with Phase 0 research

## Project Structure

### Documentation (this feature)

```text
specs/002-rest-api/
â”œâ”€â”€ spec.md              # Feature specification (533 lines, comprehensive)
â”œâ”€â”€ plan.md              # This file (/sp.plan command output)
â”œâ”€â”€ research.md          # Phase 0 output (to be created)
â”œâ”€â”€ data-model.md        # Phase 1 output (to be created)
â”œâ”€â”€ quickstart.md        # Phase 1 output (to be created)
â”œâ”€â”€ contracts/           # Phase 1 output (OpenAPI schema, to be created)
â”‚   â””â”€â”€ openapi.yaml     # Auto-generated from FastAPI, exported here
â”œâ”€â”€ checklists/          # Quality validation
â”‚   â””â”€â”€ requirements.md  # Spec quality checklist (all items PASS)
â””â”€â”€ tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
backend/                          # Existing Phase I structure, to be extended
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                  # FastAPI application entry point (NEW)
â”‚   â”œâ”€â”€ config.py                # Configuration and environment variables (NEW)
â”‚   â”œâ”€â”€ database.py              # SQLModel engine and session management (NEW)
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ task.py              # Extend existing Task model with SQLModel (MODIFY)
â”‚   â”‚   â””â”€â”€ schemas.py           # Pydantic request/response schemas (NEW)
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ task_service.py      # Task CRUD operations with SQLModel (NEW/MODIFY)
â”‚   â”œâ”€â”€ api/                     # API layer (NEW directory)
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ dependencies.py      # FastAPI dependencies (DB session, etc.)
â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ tasks.py         # Task endpoints (6 routes)
â”‚   â”‚   â””â”€â”€ middleware.py        # Logging, CORS, error handling
â”‚   â””â”€â”€ cli/                     # Phase I console app (PRESERVE)
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ menu.py              # Console menu system (unchanged)
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py              # Pytest fixtures (DB session, test client) (MODIFY)
â”‚   â”œâ”€â”€ unit/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ test_task.py         # Task model tests (PRESERVE from Phase I)
â”‚   â”‚   â”œâ”€â”€ test_task_service.py # Service layer tests (MODIFY for SQLModel)
â”‚   â”‚   â””â”€â”€ test_schemas.py      # Pydantic schema validation tests (NEW)
â”‚   â”œâ”€â”€ integration/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ test_api_tasks.py    # API endpoint integration tests (NEW)
â”‚   â”‚   â””â”€â”€ test_database.py     # Database operations tests (NEW)
â”‚   â””â”€â”€ contract/                # Contract tests (NEW directory)
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ test_openapi.py      # OpenAPI schema validation (NEW)
â”‚
â”œâ”€â”€ alembic/                     # Database migrations (NEW directory)
â”‚   â”œâ”€â”€ versions/
â”‚   â”‚   â””â”€â”€ 001_initial_schema.py # Initial tasks table migration
â”‚   â”œâ”€â”€ env.py
â”‚   â””â”€â”€ script.py.mako
â”‚
â”œâ”€â”€ .env.example                 # Environment variable template (NEW)
â”œâ”€â”€ requirements.txt             # Updated with FastAPI, SQLModel, Uvicorn, etc.
â”œâ”€â”€ requirements-dev.txt         # Dev dependencies (pytest, httpx, etc.)
â”œâ”€â”€ pyproject.toml               # Updated project configuration
â”œâ”€â”€ mypy.ini                     # Type checking configuration (existing)
â”œâ”€â”€ .pylintrc                    # Linting configuration (existing)
â””â”€â”€ README.md                    # Updated with API setup instructions (MODIFY)
```

**Structure Decision**: Backend-only web application structure (Option 2 variant). Extending existing Phase I `backend/` directory to add API layer (`src/api/`) and database integration (`src/database.py`, `alembic/`). Phase I console app code preserved in `src/cli/` for backward compatibility and potential data migration. This structure supports independent backend deployment while preparing for Phase II Step 3 frontend integration.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

**No violations** - All constitutional requirements satisfied.

## Architecture Decisions

### ADR-001: FastAPI as Web Framework

**Context**: Need a Python web framework for REST API with automatic OpenAPI documentation, modern async support, and strong type validation.

**Decision**: Use FastAPI

**Alternatives Considered**:
1. **Django REST Framework (DRF)**
   - Pros: Mature, extensive ecosystem, Django ORM integration
   - Cons: Heavier framework, slower performance, less modern async support, steeper learning curve
   - Rejected: Overkill for API-only service; Django ORM conflicts with SQLModel choice

2. **Flask + Flask-RESTful**
   - Pros: Lightweight, flexible, well-known
   - Cons: Requires manual OpenAPI documentation, no built-in validation, limited async support
   - Rejected: Too much manual work for OpenAPI docs; validation requires additional libraries

3. **FastAPI** âœ“
   - Pros:
     - Auto-generates OpenAPI/Swagger docs
     - Built-in Pydantic validation
     - Excellent async/await support
     - High performance (Starlette + Uvicorn)
     - Type hints enable IDE autocomplete
     - Minimal boilerplate
   - Cons: Younger ecosystem than Django/Flask
   - Selected: Best fit for API-only service with strong typing and auto-documentation

**Consequences**:
- Positive: Faster development, better developer experience, automatic API documentation
- Negative: Smaller community than Django; fewer third-party extensions
- Mitigation: FastAPI community is growing rapidly; core features are stable

### ADR-002: SQLModel as ORM

**Context**: Need an ORM that works with Pydantic (for FastAPI integration), supports type hints, and handles PostgreSQL well.

**Decision**: Use SQLModel

**Alternatives Considered**:
1. **SQLAlchemy Core + Pydantic**
   - Pros: Mature, full control, powerful query API
   - Cons: Requires separate Pydantic models and SQLAlchemy models (duplication)
   - Rejected: Too much boilerplate; double model definitions increase maintenance

2. **Tortoise ORM**
   - Pros: Async-native, Django-like API, Pydantic integration
   - Cons: Less mature, smaller community, potential migration challenges
   - Rejected: Less battle-tested; SQLModel has better Pydantic integration

3. **SQLModel** âœ“
   - Pros:
     - Combines SQLAlchemy and Pydantic into single model definition
     - Type hints for editor support
     - Created by FastAPI author (Sebastian Ramirez) - tight integration
     - Reduces code duplication (one model for DB and API)
     - Built on mature SQLAlchemy foundation
   - Cons: Newer library (less mature than pure SQLAlchemy)
   - Selected: Perfect fit for FastAPI + PostgreSQL with minimal boilerplate

**Consequences**:
- Positive: Single source of truth for data models; less code to maintain
- Negative: Newer library with evolving API
- Mitigation: Built on SQLAlchemy 2.0 (stable foundation); Active development

### ADR-003: Neon Serverless PostgreSQL for Database

**Context**: Need a PostgreSQL database for persistent storage with minimal operational overhead.

**Decision**: Use Neon Serverless PostgreSQL

**Alternatives Considered**:
1. **Local PostgreSQL (Docker or native)**
   - Pros: Full control, no external dependencies, free
   - Cons: Requires manual setup, backup management, no auto-scaling, local only
   - Rejected: Constitution specifies Neon DB for Phase II

2. **AWS RDS PostgreSQL**
   - Pros: Managed service, scalable, reliable
   - Cons: More expensive, slower cold starts, requires AWS account
   - Rejected: Constitution mandates Neon DB

3. **Neon Serverless PostgreSQL** âœ“
   - Pros:
     - Serverless (auto-scaling, pay-per-use)
     - Fast cold starts (<1s)
     - Branching for dev/test environments
     - Generous free tier
     - Fully managed (no backup/maintenance)
   - Cons: Newer service, vendor lock-in
   - Selected: Constitutional requirement; excellent for development and MVP

**Consequences**:
- Positive: Zero database administration; instant provisioning; branch per feature
- Negative: Vendor dependency; internet connectivity required
- Mitigation: DATABASE_URL configurable; can switch to standard PostgreSQL if needed

### ADR-004: User Isolation Pattern Without Authentication

**Context**: Need to isolate user data by user_id while deferring authentication to Step 2.

**Decision**: Use user_id path parameter with service-layer isolation checks

**Approach**:
- **URL Pattern**: `/api/{user_id}/tasks/...`
- **Trust Model**: user_id is trusted (no verification in Step 1)
- **Data Isolation**: All database queries filtered by `user_id` column
- **Service Layer**: `task_service.py` enforces user_id filtering on all CRUD operations
- **Database Schema**: Tasks table includes indexed `user_id` column (VARCHAR(50))

**Alternatives Considered**:
1. **Global task access (no user_id)**
   - Rejected: Doesn't prepare for authentication in Step 2

2. **Header-based user_id**
   - Rejected: Less RESTful; harder to test with curl/Postman

3. **Path parameter (selected)** âœ“
   - Pros: RESTful, easy to test, clear ownership model, smooth transition to auth
   - Cons: user_id visible in URL (acceptable without sensitive data)

**Migration to Step 2 (Authentication)**:
- Add middleware to extract user_id from JWT token
- Replace path parameter with authenticated user ID
- Keep database schema unchanged (user_id column already exists)
- Service layer logic remains the same (already filters by user_id)

**Consequences**:
- Positive: Clean separation of concerns; easy migration to auth; testable without auth complexity
- Negative: No security in Step 1 (acceptable for development/testing phase)
- Mitigation: Clear documentation that Step 1 is NOT production-ready

### ADR-005: Database Migration Strategy

**Context**: Need version-controlled database schema evolution from Step 1 to future steps.

**Decision**: Use Alembic for database migrations

**Alternatives Considered**:
1. **Manual SQL scripts**
   - Rejected: Not version-controlled, error-prone, no rollback support

2. **SQLModel create_all() (no migrations)**
   - Rejected: No schema versioning, can't evolve schema safely

3. **Alembic** âœ“
   - Pros: SQLAlchemy-native, version-controlled, auto-generates migrations, rollback support
   - Cons: Additional tool to learn
   - Selected: Industry standard for SQLAlchemy; essential for production

**Migration Plan**:
- **Version 001**: Initial schema (tasks table with user_id, title, is_completed, timestamps)
- **Future (Step 2)**: Add users table, foreign key constraint on tasks.user_id
- **Future (Intermediate)**: Add priority, due_date columns to tasks table

**Consequences**:
- Positive: Safe schema evolution; can roll back failed migrations; production-ready approach
- Negative: Slightly more complex setup
- Mitigation: Alembic widely documented; FastAPI + SQLModel examples available

## Phase 0: Research & Resolution

**Objective**: Resolve all technical unknowns and establish best practices for FastAPI + SQLModel + Neon integration.

### Research Tasks

1. **FastAPI Project Structure Best Practices**
   - **Unknown**: Optimal directory layout for scalable FastAPI projects
   - **Research**: FastAPI official docs, real-world projects (tiangolo's full-stack template)
   - **Outcome**: Document recommended structure in `research.md`

2. **SQLModel Connection Pooling with Neon**
   - **Unknown**: Connection pool configuration for Neon Serverless PostgreSQL
   - **Research**: Neon connection docs, SQLModel engine setup, pool sizing recommendations
   - **Outcome**: Document pool_size, max_overflow, pool_pre_ping settings

3. **FastAPI Dependency Injection for Database Sessions**
   - **Unknown**: Best pattern for managing SQLModel sessions in FastAPI routes
   - **Research**: FastAPI dependency docs, context managers, yield dependencies
   - **Outcome**: Document session-per-request pattern with automatic cleanup

4. **API Error Handling and Exception Mapping**
   - **Unknown**: How to map SQLModel exceptions to HTTP status codes
   - **Research**: FastAPI exception handlers, custom error responses
   - **Outcome**: Document exception handler patterns for 404, 422, 500 errors

5. **Testing Strategy for FastAPI + SQLModel**
   - **Unknown**: Best practices for testing API endpoints with database interactions
   - **Research**: pytest fixtures, TestClient, in-memory vs test database
   - **Outcome**: Document test database setup, fixtures, and TestClient usage

6. **OpenAPI Schema Export and Validation**
   - **Unknown**: How to export and version OpenAPI schema for contract testing
   - **Research**: FastAPI openapi.json endpoint, schema validation tools
   - **Outcome**: Document schema export process and validation approach

7. **Database Migration Workflow with Alembic**
   - **Unknown**: Step-by-step process for creating and applying migrations
   - **Research**: Alembic docs, SQLModel integration, migration best practices
   - **Outcome**: Document migration creation, review, and application workflow

8. **CORS Configuration for Future Frontend**
   - **Unknown**: CORS settings required for Next.js frontend in Step 3
   - **Research**: FastAPI CORS middleware, allowed origins configuration
   - **Outcome**: Document development and production CORS settings

**Deliverable**: `specs/002-rest-api/research.md` with all decisions, rationales, and code examples.

## Phase 1: Design & Contracts

**Objective**: Create data models, API contracts, and quick-start guide.

### 1.1 Data Model Design

**Deliverable**: `specs/002-rest-api/data-model.md`

**Content**:
- **Task Entity** (SQLModel):
  - Fields: id (int, PK), user_id (str, indexed), title (str, 1-500 chars), is_completed (bool, default False), created_at (datetime, auto), updated_at (datetime, auto-update)
  - Validations: title length (1-500), user_id format (alphanumeric + hyphens/underscores, max 50)
  - Indexes: PRIMARY KEY(id), INDEX(user_id), INDEX(user_id, is_completed) for filtered queries
  - Constraints: NOT NULL on user_id, title, is_completed; CHECK(LENGTH(title) >= 1 AND LENGTH(title) <= 500)

- **Pydantic Schemas** (API layer):
  - `TaskCreate`: title (str, 1-500 chars)
  - `TaskUpdate`: title (str, 1-500 chars)
  - `TaskResponse`: id, user_id, title, is_completed, created_at, updated_at
  - `TaskListResponse`: List[TaskResponse]

- **State Transitions**:
  - Create: is_completed=False by default
  - Complete: Toggle is_completed (falseâ†’true or trueâ†’false)
  - Update: Modify title; update updated_at timestamp
  - Delete: Hard delete (no soft delete in Step 1)

### 1.2 API Contract Generation

**Deliverable**: `specs/002-rest-api/contracts/openapi.yaml`

**Endpoints** (6 routes):

1. **GET /api/{user_id}/tasks**
   - Summary: List all tasks for user
   - Parameters: user_id (path, string, required)
   - Responses: 200 (TaskListResponse), 422 (Validation Error), 500 (Server Error)

2. **POST /api/{user_id}/tasks**
   - Summary: Create new task
   - Parameters: user_id (path, string, required)
   - Request Body: TaskCreate (application/json)
   - Responses: 201 (TaskResponse), 422 (Validation Error), 500 (Server Error)

3. **GET /api/{user_id}/tasks/{id}**
   - Summary: Get task by ID
   - Parameters: user_id (path, string, required), id (path, integer, required)
   - Responses: 200 (TaskResponse), 404 (Not Found), 422 (Validation Error), 500 (Server Error)

4. **PUT /api/{user_id}/tasks/{id}**
   - Summary: Update task title
   - Parameters: user_id (path, string, required), id (path, integer, required)
   - Request Body: TaskUpdate (application/json)
   - Responses: 200 (TaskResponse), 404 (Not Found), 422 (Validation Error), 500 (Server Error)

5. **DELETE /api/{user_id}/tasks/{id}**
   - Summary: Delete task
   - Parameters: user_id (path, string, required), id (path, integer, required)
   - Responses: 204 (No Content), 404 (Not Found), 422 (Validation Error), 500 (Server Error)

6. **PATCH /api/{user_id}/tasks/{id}/complete**
   - Summary: Toggle task completion
   - Parameters: user_id (path, string, required), id (path, integer, required)
   - Responses: 200 (TaskResponse), 404 (Not Found), 422 (Validation Error), 500 (Server Error)

**Contract Validation**:
- Auto-generated from FastAPI route definitions
- Exported to `contracts/openapi.yaml` for version control
- Validated against spec requirements in contract tests

### 1.3 Quick Start Guide

**Deliverable**: `specs/002-rest-api/quickstart.md`

**Content**:
1. **Prerequisites**: Python 3.10+, Neon account, DATABASE_URL
2. **Installation**: Clone repo, create venv, install requirements, set environment variables
3. **Database Setup**: Create Neon database, run Alembic migrations
4. **Run API**: `uvicorn src.main:app --reload`
5. **Access Docs**: `http://localhost:8000/docs` (Swagger UI)
6. **Test Endpoints**: Example curl commands for all 6 endpoints
7. **Run Tests**: `pytest tests/` with coverage report
8. **Environment Variables**: DATABASE_URL, LOG_LEVEL, CORS_ORIGINS

### 1.4 Agent Context Update

**Action**: Run `.specify/scripts/powershell/update-agent-context.ps1 -AgentType claude`

**Purpose**: Update Claude Code agent context with Phase II Step 1 technologies

**New Context Added**:
- FastAPI web framework patterns
- SQLModel ORM usage
- Neon Serverless PostgreSQL connection
- Alembic migration workflows
- pytest with httpx TestClient
- API testing best practices

**Preservation**: Existing Phase I context (console app, in-memory storage) preserved for reference

## Implementation Readiness

### Pre-Implementation Checklist

âœ… **Planning Complete**:
- [x] Specification reviewed and approved
- [x] Architecture decisions documented (5 ADRs)
- [x] Technical unknowns identified for research phase
- [x] Constitution compliance verified

âœ… **Design Artifacts Ready**:
- [ ] research.md (Phase 0 - to be created)
- [ ] data-model.md (Phase 1 - to be created)
- [ ] contracts/openapi.yaml (Phase 1 - to be created)
- [ ] quickstart.md (Phase 1 - to be created)

âœ… **Next Steps**:
1. **Phase 0**: Generate `research.md` with all technical decisions resolved
2. **Phase 1**: Generate `data-model.md`, `contracts/`, and `quickstart.md`
3. **Phase 2**: Run `/sp.tasks` to create task breakdown with test cases
4. **Implementation**: Execute tasks following TDD (Red-Green-Refactor)

### Risk Assessment

**Low Risk**:
- FastAPI is mature and well-documented
- SQLModel is stable (built on SQLAlchemy)
- Neon provides free tier for development

**Medium Risk**:
- Neon cold start latency (mitigated by connection pooling and pool_pre_ping)
- SQLModel migration from Phase I Task model (mitigated by preserving existing model structure)

**Mitigation Strategies**:
- Connection pool pre-ping to keep connections alive
- Comprehensive testing with TestClient before deployment
- Incremental migration: Keep Phase I console app working during transition

## Success Criteria

Implementation is complete when:

1. All 6 REST endpoints implemented and tested
2. Tasks persist in Neon PostgreSQL across restarts
3. User isolation enforced (users only see their own tasks)
4. OpenAPI documentation auto-generated at `/docs`
5. Test coverage â‰¥80% (unit + integration tests)
6. All API responses match OpenAPI schema
7. Error handling covers all edge cases (malformed JSON, missing fields, SQL errors)
8. Database migrations version-controlled in Alembic
9. Quick-start guide enables new developer to run API in <15 minutes
10. All HTTP status codes match specification (200, 201, 204, 404, 422, 500)
11. Pylint score â‰¥8.0/10, mypy passes with zero errors
12. API handles 100 concurrent requests with <500ms response time

---

**Plan Status**: âœ… Phase 0 Ready | ðŸ”„ Awaiting research.md generation
**Next Command**: Continue with Phase 0 research artifact generation
**Estimated Completion**: After Phase 1 artifacts (research.md, data-model.md, contracts/, quickstart.md) are generated
